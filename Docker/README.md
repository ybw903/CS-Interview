# 도커

> 컨테이너 기반 가상화 도구

## 가상화

### 🤔 가상화가 왜 필요할까?

궁금증에 앞서 이런 상황을 가정해봅니다.

1. 서버에 개발한 프로그램을 올립니다.
2. 이 때, 서버에 사용가능한 자원이 남는 경우가 발생합니다.
3. 그래서 프로그램을 하나 더 서버에 더 올리기로 합니다.
4. 하지만 기존에 프로그램과 새로운 프로그램 사이에 충돌이 발생하는 경우

따라서 가상화는 서버의 자원을 나누어 각각 프로그램에 알맞게 나누어준다고 생각할 수 있습니다.

### 서버 가상화
하나의 물리적 서버 호스트에서 여러 개의 서버 운영 체제를 게스트로 실행할 수 있게 해주는 소프트웨어 아키텍쳐입니다.

## 하이퍼 바이저

서버 가상화 기술을 구현할 수 있게 해주는 소프트웨어입니다.

이렇게 생성된 여러 개의 운영체제는 가상 머신이라는 단위로 구별합니다.

각 가상머신에는 여러 운영체제가 설치되어 사용되고 하이퍼 바이저에 의해 생성되고 관리되는 운영체제를 **게스트 운영체제**라고 부릅니다.

각 게스트 운영체제는 다른 게스트 운영체제와 완전히 독립된 공간과 시스템 자원을 할당 받아 사용합니다.

### 역할

* OS에게 자원을 나누어주며 조율
* OS들의 커널을 번역해서 하드웨어에 전달

>대표적인 가상화 툴 (eg. VirtualBox, VMWare)

### 단점
각종 시스템 자원을 가상화하고 독립된 공간을 생섣하는 작업은 **하이퍼 바이저**를 반드시 거치기 때문에 일반 호스트에 비해 성능 손실이 발생합니다.

또한, 가상 머신에는 **게스트 운영체제**를 사용하기 위한 라이브러리, 커널 등을 전부 포함하기 때문에 배포하기 위한 이미지로 만들었을 때 크기 또한 더 커집니다.

즉, 가상 머신은 완벽한 운영체제를 생성할 수 있는 장점은 있지만 성능이 느리고, 용량상으로 부담이 됩니다.

**따라서 이런 단점을 극복하기 위해 컨테이너라는 기술이 등장합니다.**

## 컨테이너
가상화된 공간을 생성하기 위해 리눅스 자체 기능인 chroot, 네임스페이스, cgroup을 사용함으로써 프로세스 단위의 격리 환경을 만듭니다.

컨테이너 안에는 애플리케이션을 구동하는데 필요한 라이브러리 및 실행 파일만 존재합니다.

그렇기 때문에 이미지로 만들었을 때, 이미지의 용량 또한 가상 머신에 비해 대폭 줄어듭니다.

따라서 이미지를 만들어 배포하는 시간이 가상머신에 비해 빠르며, 가상화된 공간을 사용할 때, 성능 손실도 거의 없다는 장점이 있습니다.

>이러한 컨테이너 기술을 도커만의 기술이 아닙니다.
<br>
도커 이외에 여러 벤더사에서도 제공합니다.

**도커는 결론적적으로 컨테이너 기술에 여러 기능을 추가한 오픈소스 프로젝트입니다.**

프로그래밍 관점에서 자주 접할 수 있는 컨테이너는 컨테이너에 담긴 것들의 **라이프 사이클**을 관리해줍니다.

가상화 관점에서의 **컨테이너란 이미지의 목적에 따라 생성되는 프로세스 단위의 격리 환경**입니다.

이 떄, 이미지는 간단히 **컨테이너를 만들기 위한 틀**이라고 생각할 수 있습니다.

컨테이너는 파일 시스템과 격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립된 공간을 가집니다.

컨테이너가 실행되며, 프로세스가 실행되기에 필요한 자원들을 할당 받고 프로세스를 실행합니다.

이 때, 커널을 통해 필요한 자원들을 가져옵니다.

**Host OS**에서는 컨테이너 환경에서 실행되는 프로세스나 직접 실행되는 프로세스나 똑같은 프로세스로 취급됩니다.

컨테이너는 **Host와의 격리를 통해 독립된 개발 환경을 보장**합니다. 컨테이너에 어떤 설정을 하든 Host OS에 영향을 끼치지 않습니다. 즉, 독립적인 개발환경을 보장받을 수 있음을 의미합니다.

 **컨테이너를 통해 프로세스를 컨테이너 단위로 바라볼 수 있게 되고 프로세스의 관리, 확장에 용이해집니다.**

### 🤔 그렇다면 컨테이너를 관리하는 방법은?

사용자는 **Docker Engine**을 통해 컨테이너를 관리할 수 있습니다.

## 도커엔진

> 도커엔진은 유저가 컨테이너를 쉽게 사용할 수 있게 하는 주체입니다.

컨테이너의 **라이프 사이클을 관리**하며, 컨테이너를 생성하기 위한 **이미지 관리**, 컨테이너 데이터를 저장하기 위한 저장소 역할을 하는 **볼륨의 관리**, 컨테이너에 접속하기 위한 **네트워크 관리** 등의 기능을 제공합니다.

### 동작

* 명령어를 입력하였을 때

    Docker 명령어로 **도커 엔진**에 명령어를 보냅니다.

    이를 전달받은 **도커 클라이언트**는 **/var/run/docker.sock**에 위치한 유닉스 소켓을 통해 **도커 데몬**의 API를 호출합니다.

    **도커 데몬은** 명령어에 해당하는 작업을 수행하고 수행결과를 **도커 클라이언트**에게 반환하며 사용자에게 결과를 출력합니다.

    >**dockerd**는 컨테이너를 생성하고 실행하며 이미지를 관리하는 주체입니다.

    도커 프로세스가 실행되어 입력을 받을 준비된 상태를 **도커 데몬**이라고 부릅니다.

* 외부 API를 통해

    도커 데몬에 직접 명령어를 전달하고 싶을 때는 url 요청을 보내 명령어와 쳤을 때와 같은 동작을 수행할 수 있습니다.

### 🤔 하나의 호스트 머신에서 컨테이너가 많아져서 CPU나 메모리, 디스크 용량과 같은 자원이 부족해 지면?

1. Scale Up

    제일 간단한 방법은 **Scale Up**으로 더욱 성능이 좋은 서버로 교체해주는 방법입니다. 하지만 자원의 확장성 측면이나 비용 측면에서 효율적인 해결방법이 아닙니다.

2. Scale Out

    가장 많이 사용하는 방법은 여러 대의 서버를 **클러스터**로 만들어 자원을 병렬로 확장하는 것입니다. 이는 **Scale out**이라고 합니다.

    >**서버 클러스터**란, 각기 다른 서버들을 하나로 묶어 시스템 같이 동작하게 함으로써 클라이언트들에게 고가용성의 서비스를 제공하는 것을 의미합니다.

    서버 클러스터는 동일한 네트워크 풀을 쓰며 요청에 따라 트랙픽을 분산시킬 수 있습니다.

    하지만 여러 대의 서버를 하나의 자원 풀로 만드는 것은 쉬운 일이 아닙니다. 새로운 서버나 컨테이너가 추가됐을 때, 이를 발견하는 작업부터, 어떤 서버에 어떤 컨테이너를 할당할 건지에 대한 작업등 처리해야 할 작업이 많습니다.

    다행히 이러한 문제들을 해결하는 여러 솔루션을 오픈소스로 활용할 수 있습니다. 그 중 대표적인 것이 **도커 스웜**입니다.

## 스웜모드
도커 스웜은 스웜모드를 지원해주는데 스웜모드는 마이크로 서비스 아키텍쳐의 컨테이너를 다루기 위한 클러스터링 기능에 초점을 맞추고 있습니다.

* 같은 컨테이너를 동시에 여러 개 생성해 필요에 따라 유동적으로 컨테이너 수를 조절할 수 있습니다.

* 컨테이너로의 연결을 분산하는 로드 밸런싱 기능을 자체적으로 지원합니다.

* Scale out은 지원하지만 자체적으로 인스턴스를 늘리거나 줄이거나 할 수 없고 개발자가 직접 늘려줘야 합니다.

* 스웜은 도커 엔진 자체에 내장되어 있습니다.

### 구조
스웜모드는 **매니저 노드 + 워커 노드**로 구성되어 있습니다. 워커 노드는 **실제로 컨테이너가 생성되고 관리되는 도커 서버**이고 매니저 노드는 **워커 노드를 관리하기 위한 도커 서버**입니다. 매니저 노드는 기본적으로 워커 노드의 역할을 포합합니다. 

**매니저 노드는 운영환경에서 다중화를 하는 것이 좋습니다.** 매니저 노드의 부하를 분산하고, 특정 매니저 노드가 다운됐을 때, 정상적으로 스웜 클러스터를 유지할 수 있기 때문이니다.

### 클러스터 구축

1. ```docker Swarm init``` 명령어로 매니저 노드를 설정해줍니다.

2. ```docker swarm join```을 통해 노드를 추가해줍니다.

워커 노드를 추가함으로써 하나의 클러스터 단위가 완성됩니다. 이제 서비스를 시작할 수 있습니다.

### 서비스
일반적인 도커 명령어의 제어 단위는 **컨테이너**입니다. 이는 **도커 클라이언트**가 제어하는 것은 **컨테이너**라는 것을 의미합니다.

도커 스웜에서 제어 단위는 서비스입니다. 서비스는 **같은 이미지에서 생성된 컨테이너의 집합을 의미합니다.**

서비스를 제어하면 해당 서비스 내의 컨테이너에 같은 명령이 수행됩니다. 이 때, 서비스 내의 컨테이너를 **task**라 부릅니다. 서비스의 정의에 따라 **task**를 할당할 적합한 노드를 선정하고 선택한 노드에 **task**를 분산해서 할당됩니다. 함께 생성된 **task**를 **레플리카**라 하고 서비스에 설정된 **레플리카**의 수만큼 **task**가 스웜 클러스터 내에 존재해야합니다.

>이외에도 **스웜모드**에서는 **클러스터 관리**, **서비스 관리**, 클러스터의 **네트워크를 관리**하는 기능, 클러스터 내의 **노드를 관리**하는 기능들을 제공합니다.
<br>

**스웜모드는 서비스의 확장/관리를 편하게 하기위해 사용합니다.**

### 🤔 컨테이너를 어떻게 효율적으로 생성할까?
도커 컴포즈를 사용합니다.

## 도커 컴포즈
**도커 컴포즈**는 여러 개의 **컨테이너**를 하나의 **서비스**로 정의하고 실행합니다.

* 스웜모드의 서비스와 유사하게 설정 파일에 정의된 서비스의 컨테이너 수를 유동적으로 조절할 수 있습니다.
* 서비스 디스커버리도 자동적으로 이루어집니다.
* 도커 컴포즈는 도커 엔진 밖에 위치합니다. 도커 엔진 밖에 위치하기 때문에 도커에 내장되어 있지 않고 컴포즈를 직접 설치해야 합니다.

### 플로우
**컨테이너의 설정이 정의된 yml파일**을 읽어 도커엔진을 통해 컨테이너를 생성합니다.

 따라서 도커 컴포즈를 사용하려면 yml파일을 먼저 작성해야 합니다.

파일을 작성 후 **docker-compose** 명령어를 통해 컨테이너를 생성할 수 있습니다.


### 구조
기본적으로 **docker-compose.yml**이 위치한 디렉터리 이름을 프로젝트 이름으로 사용합니다.

하나의 **프로젝트**는 여러 개의 **서비스**로 이루어지고 하나의 **서비스**에는 여러 개의 **컨테이너**가 존재할 수 있습니다. 각각의 **컨테이너**는 번호를 붙여 **서비스** 내의 **컨테이너**를 구별합니다.


**도커 컴포즈는 컨테이너의 생성을 편리하게 하기 위해 사용합니다.**
