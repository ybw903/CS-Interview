## Nginx
Nginx는 웹서버이며 리버스 프록시, 로드 밸런서, HTTP 캐시로도 쓰일 수 있는 소프트웨어입니다. 요청에 응답하기 위해 이벤트 기반 구조를 사용하고 있으며 현재 웹 서버 분야에서 1등으로 사용되고 있습니다.

* 이벤트 기반 구조는 뭐고?

* Apache가 아니라 왜 Nginx가 1등인가?

### Apache

Apache는 요청이 들어올 때 마다 Connection을 형성하기 위해 프로세스를 생성합니다.

프로세스를 요청이 들어올 때마다 생성하게 되면 시간 상 오버헤드가 발생하기 때문에 요청이 들어오기 전에 프로세스를 미리 만들어둡니다.

그래서 새로 요청이 들어 올 때마다 이전에 만들어둔 프로세스를 사용하였습니다.

만약, 만들어둔 프로세스를 모두 할당되었다면 추가로 프로세스를 생성하였습니다.

따라서 이런 구조는 개발하기에 쉬운 장점이 있어 개발자는 다양한 모듈을 개발하여 서버에 빠르게 기능을 추가할 수 있었습니다.

또한, 요청을 받고 응답을 해주는 과정을 하나의 서버에서 해결해줄 수 있었습니다.

**C10k**

Connection 10,000 Problem(1,999년)

동시에 연결된 커넥션 수와 초당 요청 처리 수가 일치하지 않음

이를 해결하기 위해 Keep-Alive Header를 사용하여 만들어둔 커넥션을 재활용합니다.

이 때, 동시 커넥션 수가 10,000 단위를 넘어서게 되면 서버는 더 이상 커넥션을 형성하지 못하는 문제를 의미합니다.

하드웨어 문제가 아니라 아파치 서버구조로 인해 발생

미리 생성된 프로세스로 인해 **메모리 부족**, 개발자가 추가한 모듈이 **무거운 프로그램**이 되고, 그에 따라 컨텍스트 스위칭과정이 발생할 떄, **많은 CPU 부하**가 발생되어 문제가 되었습니다.

즉, 수 많은 동시커넥션을 감당하기에 아파치 서버는 부적합하였습니다.

### Nginx (2004년)

초창기 Nginx는 Apache서버와 함께 사용하기 위해 등장.

Apache서버가 가진 구조적 한계를 Nginx를 사용하여 극복하기 위함.

Apache서버 앞단에 Nginx를 배치. 이렇게 배치함으로써 수 많은 동시 커넥션을 Nginx에서 유지.

Nginx자체가 웹서버이므로 정적파일은 스스로 처리하고 동적파일을 요청받았을 때만, 뒤에 Apache서버와 connection을 형성합니다. 

Apache서버의 프로세스를 커넥션을 형성하는데 모두 사용하지 않고 개발자가 작성한 모듈의 로직처리를 수행하는데 사용할 수 있게 되었습니다.

**그러면 Nginx는 어떻게 수 많은 동시커넥션을 유지할 수 있었을까?**

* master process: 설정을 읽고 설정에 맞게 worker process를 생성합니다.

* worker process: 실제로 요청을 처리하는 프로세스로 처음 생성 시 지정된 listen socket을 배정받습니다. 

    그리고 socket에 요청이 들어올 경우, 커넥션을 형성하고 요청을 처리해줍니다. 이 때, connection은 keep-alive시간 만큼 유지가 됩니다.
    
    worker process는 이 때, 아무 작업도 처리안하는 것이 아니라 새로 connection을 형성하거나 다른 connection으로 부터의 요청을 처리해줍니다.

Nginx에서는 이런 **커넥션 형성**, **제거**, 그리고 **새로운 요청을 처리**하는 것을 **이벤트**라고 부릅니다.

그리고 이러한 이벤트들은 OS커널이 큐 형식으로 worker process에게 전달해줍니다.

이 때, 이벤트는 큐에 담긴 상태에서 worker process가 처리해줄 때까지 **비동기**방식으로 대기합니다.

그리고 worker process는 하나의 스레드로 이벤트를 꺼내서 요청을 처리해줍니다.

이러면 worker process는 쉬지 않고 계속 동작되는 장점이 있습니다. apache서버의 경우와 대비하여 사용되지 않는 프로세스가 발생되지 않으므로 효율적으로 서버의 자원을 사용할 수 있습니다. (메모리 부족 해결)

**!! 이 때, I/O작업과 같이 오래걸리는 작업이 이벤트로 발생되면 Convoy Effect가 발생되는게 아닐까? !!**

Nginx는 이러한 경우를 대비하여 오래 걸리는 작업을 처리하기 위한 별도의 **스레드풀**을 생성해 둡니다.

worker process는 시간이 오래걸리는 작업은 스레드 풀에 위임하고 다음 이벤트를 계속해서 처리해 나갑니다.

이런 worker process는 보통 CPU의 코어 수만큼 생성합니다.

이렇게 생성하면 context switching 발생을 대폭적으로 줄일 수 있습니다.

이러한 전체적인 구조가 **이벤트 기반 구조**로 Apache 서버와 가장 큰 차이점입니다.

**Nginx 단점**

개발자가 만약 기능을 추가할 경우, 동작중이던 worker process를 종료시키는 상황이 발생될 수 도 있습니다.

따라서, Nginx는 개발자가 직접 모듈을 만들기는 어렵습니다.

**Nginx 장점**

* 동일 커넥션 양 최소 10배 증가(일반적으로)

* 동일한 커넥션 수일 때, 속도 2배 향상

* 동적 설정 변경 
    
    => 뒷단에 서버를 추가하여 로드밸런싱 기능을 사용하고자 할 때, 계속 클라이언트로부터 요청을 처리하면서 서버를 추가할 수 있습니다.

### 2008년

모바일 기기의 등장과 웹 컨텐츠가 비대해짐에 따라 동시커넥션을 처리해야하는 경우가 빈번히 발생되기 시작하였습니다.

이 때부터, Nginx의 점유율이 급격하게 증가되었습니다.

하지만, Apache는 기존에 잦은 버그를 해결하기 위해 등장한 서버인만큼 다양한 OS에서 안정적으로 운영할 수 있지만, Nginx는 Window OS에서 제대로 된 성능을 발휘하지 못합니다.

즉, Nginx와 Apache는 서로 사용 목적이 다르다고 이해할 수 있습니다.

### Nginx의 주요 기능

* 웹 서버
* 로드 밸런서
* SSL 터미네이션
* 캐싱
* HSTS
* CORS처리
* TCP/UDP 커넥션 부하 분산
* HTTP/2